{"meta":{"title":"LlyBlog","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"angularRoute","date":"2017-11-25T01:56:56.087Z","updated":"2017-11-25T02:13:28.084Z","comments":true,"path":"2017/11/25/angularRoute/","link":"","permalink":"http://yoursite.com/2017/11/25/angularRoute/","excerpt":"","text":"Angular路由复用策略一、引言路由在执行过程中对组件无状态操作，即路由离退时组件状态也一并被删除；当然在绝大多数场景下这是合理的。 但有时一些特殊需求会让人半死亡状态，当然这一切都是为了用户体验；一种非常常见场景，在移动端中用户通过关键词搜索商品，而死不死的这样的列表通常都会是自动下一页动作，此时用户好不容易滚动到第二页并找到想要看的商品时，路由至商品详情页，然后一个后退……用户懵逼了。 Angular路由与组件一开始就透过 RouterModule.forRoot 形成一种关系，当路由命中时利用 ComponentFactoryResolver 构建组件，这是路由的本质。 而每一个路由并不一定是一次性消费，Angular 利用 RouteReuseStrategy 贯穿路由状态并决定构建组件的方式；当然默认情况下DefaultRouteReuseStrategy像开头说的，一切都不进行任何处理。 RouteReuseStrategy 从2就已经是实验性，当前依然如此，这么久应该是可信任。 二、RouteReuseStrategyRouteReuseStrategy 我称它为：路由复用策略；并不复杂，提供了几种办法通俗易懂的方法： shouldDetach 是否允许复用路由 store 当路由离开时会触发，存储路由 shouldAttach 是否允许还原路由 retrieve 获取存储路由 shouldReuseRoute 进入路由触发，是否同一路由时复用路由 这看起来就像是一个时间轴关系，用一种白话文像是这样：把路由 /list 设置为允许复用（shouldDetach），然后将路由快照存在 store 当中；当 shouldReuseRoute 成立时即：再次遇到 /list 路由后表示需要复用路由，先判断 shouldAttach 是否允许还原，最后从 retrieve 拿到路由快照并构建组件。 当理解这一原理时，假如我们拿开头搜索列表返回的问题就变得非常容易解决。 三、一个示例诚如上面说明的，只需要实现 RouteReuseStrategy 接口即可自定义一个路由利用策略。 创建策略 1234567891011121314151617181920212223242526272829303132333435import &#123;RouteReuseStrategy, DefaultUrlSerializer, ActivatedRouteSnapshot, DetachedRouteHandle&#125; from '@angular/router';export class SimpleReuseStrategy implements RouteReuseStrategy &#123; /** 定义一个 _cacheRouters 用于缓存数据（路由快照及当前组件实例对象）。 */ _cacheRouters: &#123; [key: string]: any &#125; = &#123;&#125;; /** 表示对所有路由允许复用 如果你有路由不想利用可以在这加一些业务逻辑判断 */ shouldDetach(route: ActivatedRouteSnapshot): boolean &#123; return true; &#125; /** 当路由离开时会触发。按path作为key存储路由快照&amp;组件当前实例对象 */ store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void &#123; this._cacheRouters[route.routeConfig.path] = &#123; snapshot: route, handle: handle &#125;; &#125; /** 若 path 在缓存中有的都认为允许还原路由 */ shouldAttach(route: ActivatedRouteSnapshot): boolean &#123; return !!this._cacheRouters[route.routeConfig.path]; &#125; /** 从缓存中获取快照，若无则返回nul */ retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle &#123; return this._cacheRouters[route.routeConfig.path].handle; &#125; /** 进入路由触发，判断是否同一路由 */ shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean &#123; return future.routeConfig === curr.routeConfig; &#125;&#125; ​ 定义一个 _cacheRouters 用于缓存数据（路由快照及当前组件实例对象）。 shouldDetach 直接返回 true 表示对所有路由允许复用 store 当路由离开时会触发。按path作为key存储路由快照&amp;组件当前实例对象；path等同RouterModule.forRoot中的配置。 shouldAttach 若 path 在缓存中有的都认为允许还原路由 retrieve 从缓存中获取快照，若无则返回null shouldReuseRoute 进入路由触发，判断是否同一路由 注册 最后将策略注册到模块当中： 123providers: [ &#123; provide: RouteReuseStrategy, useClass: SimpleReuseStrategy &#125;] 假设我们有这么一个路由配置 1234RouterModule.forRoot([ &#123; path: 'search', component: SearchComponent &#125;, &#123; path: 'edit/:id', component: EditComponent &#125;]) ​","categories":[],"tags":[]},{"title":"shadowsocks","slug":"shadowsocks","date":"2017-09-03T06:16:25.000Z","updated":"2017-09-03T06:17:15.697Z","comments":true,"path":"2017/09/03/shadowsocks/","link":"","permalink":"http://yoursite.com/2017/09/03/shadowsocks/","excerpt":"","text":"Bandwagonhost VPS 搭配 Shadowsocks搭建个人VPN服务1https://bandwagonhost.com/index.php 登录上方网站注册购买VPS服务器。由于只是用于VPN，所以选择一个最低配置的VPS服务器就足够了。 年付VPS服务器较为划算，如果只是短期使用VPN也可以选择月付，根据个人需要选择即可，服务器地址个人推荐选择美国西海岸-洛杉矶。 更新个人信息，付款购买即可。 上面都是简单的购买流程不做过多累述，下面才是重要的搭建步骤： 登录服务器 输入电子邮箱地址和密码进行登录 登录成功点击Services服务器按钮，点击弹出的下拉窗中的My Services我的服务器按钮。 跳转到服务器列表页面，点击KiwiVM Control Panel按钮。 更新操作系统，如果操作系统不是64位的CentOS 6。需要先停止VPS，并且重新安装VPS选择centos-6-x86_64。 ​ 最后选择右下角的Shadowsocks Server安装Shadowsocks Server服务器即可。 下载Shadowsocks即可","categories":[],"tags":[]},{"title":"常用的git操作","slug":"git","date":"2017-08-27T17:02:14.000Z","updated":"2017-08-27T17:03:49.369Z","comments":true,"path":"2017/08/28/git/","link":"","permalink":"http://yoursite.com/2017/08/28/git/","excerpt":"","text":"常用git操作","categories":[],"tags":[]},{"title":"github.io博客搭建和Hexo博客事宜","slug":"blogByHexo","date":"2017-08-27T15:36:10.000Z","updated":"2017-08-27T17:23:51.548Z","comments":true,"path":"2017/08/27/blogByHexo/","link":"","permalink":"http://yoursite.com/2017/08/27/blogByHexo/","excerpt":"","text":"搭建环境准备配置环境准备分为如下三个步骤： Node环境的搭建 Git环境的搭建 gitHub账号的配置 配置Node环境下载node.js安装文件： node v6.11.2 LTS node v8.4.0 Current 下载完成后，启动安装程序，一直下一步完成安装。安装成功如图： node.js安装成功之后不要回头检查一下安装过程是否出现问题。检查方法打开cmd命令输入: 12npm -vnode -v 表示node环境安装成功。 Git环境配置下载git安装文件： 32-bit Git 64-bit Git 下载完成后，启动安装程序，一直下一步完成安装。安装完成后检查一下git是不是安装正确了,打开cmd命令输入: 1git --version 表示git环境安装成功。 gitHub账号的配置通过repository新建代码库。 在Repository name下填写yourname.github.io。如图： 由于我已经新建了同名的luolinyuan.github.io提升了已经存在。 以上基本的环境已经搭建完成。那么现在就需要另一个神器了—Hexo。 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即 可利用靓丽的主题生成静态网页。 初始化Hexo项目新建一个Hexo项目文件夹，使用以下命令初始一个Hexo博客项目 12hexo initnpm install 项目安装成功之后你会看到目录的树形结构如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 此时你已经可以在本地起一个服务访问到该Hexo项目了： 12hexo generate // 生成站点的命令hexo server // 启动服务器 这个时候你就可以在locolhost:4000上访问到你的Hexo项目了 Hexo项目部署到gitHub Page打开Hexo项目下的_config.yml文件，在文件结尾添加信息： 1234deploy: type: git repo: &lt;repository url&gt; branch: [branch] 为了在执行hexo g的时候可以正确的识别git type，需要安装hexo-deployer-git插件： 1npm install hexo-deployer-git --save 这个时候你就可以把本地项目和github项目进行关联了： 12git initgit remote add origin git@github.com:&#123;username&#125;/&#123;username&#125;.github.io.git 关联项目成功后，可以执行部署命令： 1hexo deploy 这时候你的Hexo项目就已经部署成功了，你可以在浏览器中输入{username}.github.io进行访问了。 这个时候你就可以愉快的在gitHub在发布你的文章了。 更多的Hexo操作详看Hexo文档","categories":[],"tags":[]}]}